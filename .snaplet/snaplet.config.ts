// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference path=".snaplet/snaplet.d.ts" />
// This config was generated by Snaplet make sure to check it over before using it.
import { copycat, faker } from "@snaplet/copycat";
import { defineConfig } from "snaplet";
export default defineConfig({
  transform: {
    $mode: "unsafe",
    auth: {
      audit_log_entries({ row }) {
        return {
          ip_address: copycat.scramble(row.ip_address),
        };
      },
      flow_state({ row }) {
        return {
          auth_code: copycat.state(row.auth_code),
          provider_type: copycat.state(row.provider_type),
          provider_access_token: copycat.uuid(row.provider_access_token),
          provider_refresh_token: copycat.uuid(row.provider_refresh_token),
        };
      },
      identities({ row }) {
        return {
          identity_data: {
            [copycat.word(row.identity_data)]: copycat.words(row.identity_data),
          },
        };
      },
      mfa_challenges({ row }) {
        return {
          ip_address: copycat.ipv4(row.ip_address),
        };
      },
      mfa_factors({ row }) {
        return {
          secret: copycat.streetAddress(row.secret),
        };
      },
      refresh_tokens({ row }) {
        return {
          token: copycat.scramble(row.token, {
            preserve: [],
          }),
          parent: copycat.scramble(row.parent, {
            preserve: [],
          }),
        };
      },
      saml_providers({ row }) {
        return {
          metadata_xml: copycat.sentence(row.metadata_xml),
          attribute_mapping: {
            [copycat.word(row.attribute_mapping)]: copycat.words(
              row.attribute_mapping
            ),
          },
        };
      },
      saml_relay_states({ row }) {
        return {
          for_email: copycat.email(row.for_email),
          from_ip_address: copycat.ipv4(row.from_ip_address),
        };
      },
      sso_domains({ row }) {
        return {
          domain: copycat.email(row.domain),
        };
      },
      users({ row }) {
        return {
          role: copycat.fullName(row.role, {
            limit: 255,
          }),
          email: copycat.email(row.email, {
            limit: 255,
          }),
          encrypted_password: copycat.scramble(row.encrypted_password),
          confirmation_token: copycat.scramble(row.confirmation_token, {
            preserve: [],
          }),
          recovery_token: copycat.scramble(row.recovery_token, {
            preserve: [],
          }),
          email_change_token_new: copycat.scramble(row.email_change_token_new, {
            preserve: [],
          }),
          email_change: copycat.email(row.email_change, {
            limit: 255,
          }),
          raw_app_meta_data: {
            [copycat.word(row.raw_app_meta_data)]: copycat.words(
              row.raw_app_meta_data
            ),
          },
          raw_user_meta_data: {
            [copycat.word(row.raw_user_meta_data)]: copycat.words(
              row.raw_user_meta_data
            ),
          },
          phone: copycat.phoneNumber(row.phone),
          phone_change: copycat.phoneNumber(row.phone_change),
          phone_change_token: copycat.scramble(row.phone_change_token, {
            preserve: [],
          }),
          email_change_token_current: copycat.scramble(
            row.email_change_token_current,
            {
              preserve: [],
            }
          ),
          reauthentication_token: copycat.scramble(row.reauthentication_token, {
            preserve: [],
          }),
        };
      },
    },
    storage: {
      migrations({ row }) {
        return {
          hash: copycat.scramble(row.hash),
        };
      },
      objects({ row }) {
        return {
          metadata: {
            [copycat.word(row.metadata)]: copycat.words(row.metadata),
          },
        };
      },
    },
    public: {
      consultants({ row }) {
        return {
          percent: copycat.float(row.percent, {
            max: Math.pow(2, 4),
          }),
        };
      },
      earnings({ row }) {
        return {
          date: copycat.dateString(row.date, {
            minYear: 2020,
          }),
          value: copycat.float(row.value, {
            max: Math.pow(2, 8),
          }),
        };
      },
      items({ row }) {
        return {
          variables: {
            [copycat.word(row.variables)]: copycat.words(row.variables),
          },
        };
      },
      prices({ row }) {
        return {
          active: copycat.bool(row.active),
          unit_amount: copycat.int(row.unit_amount, {
            min: 0,
            max: Math.pow(8, 8) - 1,
          }),
          currency: copycat.sentence(row.currency),
          interval_count: copycat.int(row.interval_count, {
            min: 0,
            max: Math.pow(4, 8) - 1,
          }),
          metadata: {
            [copycat.word(row.metadata)]: copycat.words(row.metadata),
          },
        };
      },
      products({ row }) {
        return {
          metadata: {
            [copycat.word(row.metadata)]: copycat.words(row.metadata),
          },
        };
      },
      subscriptions({ row }) {
        return {
          metadata: {
            [copycat.word(row.metadata)]: copycat.words(row.metadata),
          },
        };
      },
      users({ row }) {
        return {
          name: copycat.sentence(row.name),
          payment_method: {
            [copycat.word(row.payment_method)]: copycat.words(
              row.payment_method
            ),
          },
          role: copycat.int(row.role, {
            min: 0,
            max: Math.pow(4, 8) - 1,
          }),
        };
      },
    },
    pgsodium: {
      key({ row }) {
        return {
          name: copycat.fullName(row.name),
          associated_data: copycat.sentence(row.associated_data),
          parent_key: copycat.uuid(row.parent_key),
          comment: copycat.uuid(row.comment),
          user_data: copycat.sentence(row.user_data),
        };
      },
    },
    realtime: {
      subscription({ row }) {
        return {
          claims: {
            [copycat.word(row.claims)]: copycat.words(row.claims),
          },
        };
      },
    },
  },
  subset: {
    enabled: true,
    version: "3",
    targets: [
      {
        table: "auth.users",
        rowLimit: 1,
      },
    ],
    keepDisconnectedTables: false,
    followNullableRelations: true,
    maxCyclesLoop: 0,
    eager: false,
  },
});
